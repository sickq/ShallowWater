#pragma kernel IntergalTransmittanceLUT
#pragma kernel NewMultiScattCS
#pragma kernel IntergalSkyViewLutPS
#pragma kernel IntergalCameraVolumeLUT

#pragma multi_compile _ MULTISCATAPPROX_ENABLED
#include "./RenderSkyRayMarching.hlsl"

RWTexture2D<float4> _TransmittanceLUT;
RWTexture2D<float3> _SkyViewLUT;
RWTexture3D<float4> _CameraVolumeLUT;

[numthreads(8, 8, 1)]
void IntergalTransmittanceLUT(uint3 id: SV_DispatchThreadID)
{
    float2 pixPos = id.xy + 0.5f;

    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    // Compute camera position from LUT coords
    float2 uv = (pixPos) / float2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
    float viewHeight;
    float viewZenithCosAngle;
    UvToLutTransmittanceParams(Atmosphere, viewHeight, viewZenithCosAngle, uv);

    //  A few extra needed constants
    float3 WorldPos = float3(0.0f, 0.0f, viewHeight);
    float3 WorldDir = float3(0.0f, sqrt(1.0 - viewZenithCosAngle * viewZenithCosAngle), viewZenithCosAngle);

    IntegrateScatteredParam IntegrateScatteredParams = (IntegrateScatteredParam)0;
    {
        IntegrateScatteredParams.MieRayPhase = false;
        IntegrateScatteredParams.MiePhaseValue = 0;
        IntegrateScatteredParams.RayleighPhaseValue = 1;
    }
    
    const bool ground = false;
    const float SampleCountIni = 10.0f; // Can go a low as 10 sample but energy lost starts to be visible.
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    float3 transmittance = exp(-IntegrateScatteredLuminance(uv, WorldPos, WorldDir, sun_direction, gSunIlluminance, Atmosphere,
                                                            ground, SampleCountIni, DepthBufferValue,
                                                            VariableSampleCount, IntegrateScatteredParams).OpticalDepth);

    _TransmittanceLUT[id.xy] = float4(transmittance, 1.0f);
}

[numthreads(16, 4, 1)]
void IntergalCameraVolumeLUT(uint3 id: SV_DispatchThreadID)
{
    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    float3 pixPos = id.xyz + 0.5f;
    float3 pixPosUV = pixPos * CameraAerialPerspectiveVolumeParam3.yzw;
    float2 uv = pixPosUV.xy;
    
    float2 yz = pixPosUV.yz * pixPosUV.yz;
    yz = yz * CameraAerialPerspectiveVolumeParam.xy - float2(CameraAerialPerspectiveVolumeParam.w, 0);
    float yzLength = sqrt(dot(yz, yz));

    float yzLengthOffset = yzLength - CameraAerialPerspectiveVolumeParam3.x;
    if(yzLengthOffset <= 0)
    {
        _CameraVolumeLUT[id] = float4(0, 0, 0, 0);
        return;
    }

    float3 WorldPos = float3(0, 0, Atmosphere.BottomRadius + CameraAerialPerspectiveVolumeParam.w);
    
    float4 worldDirTemp = 0;
    float aaa = pixPosUV.x * pixPosUV.x * PI + CameraAerialPerspectiveVolumeParam2.z;
    float sinValue = sin(aaa);
    float cosValue = cos(aaa);

    worldDirTemp.zw = yz / yzLength;
    worldDirTemp.x = cosValue * worldDirTemp.w;
    worldDirTemp.y = sinValue * worldDirTemp.w;
    
    float3 WorldDir = worldDirTemp.xyz;

    float3 SunDir = sun_direction;

    float offset = worldDirTemp.z <= 0 ? 1.0f : 0.0f;
    offset = offset * CameraAerialPerspectiveVolumeParam3.x;
    WorldPos = offset * worldDirTemp + WorldPos;
    
    float Slice = ((id.z + 0.5f) / AP_SLICE_COUNT);
    Slice *= Slice; // squared distribution
    Slice *= AP_SLICE_COUNT;
    
    // Compute position from froxel information
    float tMax = AerialPerspectiveSliceToDepth(Slice);
    float3 newWorldPos = WorldPos + tMax * WorldDir;

    // If the voxel is under the ground, make sure to offset it out on the ground.
    float viewHeight = length(newWorldPos);
    if (viewHeight <= (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET))
    {
        // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
        newWorldPos = normalize(newWorldPos) * (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET + 0.001f);
        WorldDir = normalize(newWorldPos - WorldPos);
        tMax = length(newWorldPos - WorldPos);
    }
    float tMaxMax = tMax;

    // Phase functions
    float cosTheta = dot(SunDir, WorldDir);
    float MiePhaseValue = hgPhaseSimple(Atmosphere.MiePhaseG, AtmosParam.z, -cosTheta);

    float uniformMiePhase = MiePhaseValue;
    
    // mnegate cosTheta because due to WorldDir being a "in" direction. 
    float RayleighPhaseValue = RayleighPhase(cosTheta);

    float3 atmosColor = RayleighPhaseValue * AtmosParam2.xyz + uniformMiePhase * AtmosParam1.xyz;

    float3 atmosColor1 = atmosColor - uniformMiePhase;
    atmosColor1 = AtmosParam.y * atmosColor1 + uniformMiePhase;

    float3 atmosColor2 = atmosColor - RayleighPhaseValue;
    atmosColor2 = AtmosParam.y * atmosColor2 + RayleighPhaseValue;

    IntegrateScatteredParam IntegrateScatteredParams = (IntegrateScatteredParam)0;
    {
        IntegrateScatteredParams.MieRayPhase = true;
        // IntegrateScatteredParams.MiePhaseValue = MiePhaseValue;
        // IntegrateScatteredParams.RayleighPhaseValue = RayleighPhaseValue;
        IntegrateScatteredParams.MiePhaseValue = atmosColor1;
        IntegrateScatteredParams.RayleighPhaseValue = atmosColor2;
    }
    
    const bool ground = true;
    const float SampleCountIni = max(1.0, float(id.z + 1.0) * 2.0f);
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    SingleScatteringResult ss = IntegrateScatteredLuminance(uv, WorldPos, WorldDir, SunDir, gSunIlluminance, Atmosphere, ground,
                                                            SampleCountIni, DepthBufferValue, VariableSampleCount,
                                                            IntegrateScatteredParams, tMaxMax);


    const float Transmittance = dot(ss.Transmittance, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
    _CameraVolumeLUT[id] = float4(ss.L, 1.0 - Transmittance);
}

[numthreads(8, 8, 1)]
void IntergalSkyViewLutPS(uint3 id: SV_DispatchThreadID)
{
    float2 pixPos = id.xy + 0.5f;
    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    // float3 WorldPos = camera + float3(0, 0, Atmosphere.BottomRadius);
    float3 WorldPos = float3(0, 0, Atmosphere.BottomRadius + CameraAerialPerspectiveVolumeParam.w);
    // float2 uv = pixPos / float2(192.0, 108.0);
    float2 uv = pixPos / float2(96.0, 104.0);
    
    uv.x = uv.x * 1.0105263;
    uv.y = -uv.y * 2.01941752 + 1.0;

    float weight = 1 - saturate(-uv.y);
    
    float worldDirZ = max(uv.y, 0);
    float3 worldDirTemp = 0;
    worldDirTemp.z = worldDirZ;

    float sinZ = sqrt(1 - worldDirZ * worldDirZ);

    float aaa =  uv.x * uv.x * PI + CameraAerialPerspectiveVolumeParam2.z;
    float sinValue = sin(aaa);
    float cosValue = cos(aaa);

    worldDirTemp.x = cosValue * sinZ;
    worldDirTemp.y = sinValue * sinZ;
    
    float3 WorldDir = worldDirTemp;

    float viewHeight = length(WorldPos);

    float3 SunDir = sun_direction;
    
    WorldPos = float3(0.0f, 0.0f, viewHeight);

    // Move to top atmospehre
    if (!MoveToTopAtmosphere(WorldPos, WorldDir, Atmosphere.TopRadius))
    {
        // Ray is not intersecting the atmosphere
        _SkyViewLUT[id.xy] = float3(0, 0, 0);
        return;
    }

    // Phase functions
    float cosTheta = dot(SunDir, WorldDir);
    float MiePhaseValue = hgPhaseSimple(Atmosphere.MiePhaseG, AtmosParam.z, -cosTheta);

    float uniformMiePhase = MiePhaseValue;
    
    // mnegate cosTheta because due to WorldDir being a "in" direction. 
    float RayleighPhaseValue = RayleighPhase(cosTheta);

    float3 atmosColor = RayleighPhaseValue * AtmosParam2.xyz + uniformMiePhase * AtmosParam1.xyz;

    float3 atmosColor1 = atmosColor - uniformMiePhase;
    atmosColor1 = AtmosParam.y * atmosColor1 + uniformMiePhase;

    float3 atmosColor2 = atmosColor - RayleighPhaseValue;
    atmosColor2 = AtmosParam.y * atmosColor2 + RayleighPhaseValue;

    IntegrateScatteredParam IntegrateScatteredParams = (IntegrateScatteredParam)0;
    {
        IntegrateScatteredParams.MieRayPhase = true;
        // IntegrateScatteredParams.MiePhaseValue = MiePhaseValue;
        // IntegrateScatteredParams.RayleighPhaseValue = RayleighPhaseValue;
        IntegrateScatteredParams.MiePhaseValue = atmosColor1;
        IntegrateScatteredParams.RayleighPhaseValue = atmosColor2;
    }
    
    const bool ground = true;
    const float SampleCountIni = 15;
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(uv, WorldPos, WorldDir, SunDir, gSunIlluminance, Atmosphere, ground,
                                                            SampleCountIni, DepthBufferValue, VariableSampleCount,
                                                            IntegrateScatteredParams);
    _SkyViewLUT[id.xy] = ss.L * weight;
}
